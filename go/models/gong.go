// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Classdiagrams map[*Classdiagram]struct{}
	Classshapes map[*Classshape]struct{}
	Fields map[*Field]struct{}
	GongdocCommands map[*GongdocCommand]struct{}
	GongdocStatuss map[*GongdocStatus]struct{}
	Links map[*Link]struct{}
	Pkgelts map[*Pkgelt]struct{}
	Positions map[*Position]struct{}
	States map[*State]struct{}
	Umlscs map[*Umlsc]struct{}
	Vertices map[*Vertice]struct{}
	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback OnInitCommitInterface
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitClassdiagram(classdiagram *Classdiagram)
	CheckoutClassdiagram(classdiagram *Classdiagram)
	CommitClassshape(classshape *Classshape)
	CheckoutClassshape(classshape *Classshape)
	CommitField(field *Field)
	CheckoutField(field *Field)
	CommitGongdocCommand(gongdoccommand *GongdocCommand)
	CheckoutGongdocCommand(gongdoccommand *GongdocCommand)
	CommitGongdocStatus(gongdocstatus *GongdocStatus)
	CheckoutGongdocStatus(gongdocstatus *GongdocStatus)
	CommitLink(link *Link)
	CheckoutLink(link *Link)
	CommitPkgelt(pkgelt *Pkgelt)
	CheckoutPkgelt(pkgelt *Pkgelt)
	CommitPosition(position *Position)
	CheckoutPosition(position *Position)
	CommitState(state *State)
	CheckoutState(state *State)
	CommitUmlsc(umlsc *Umlsc)
	CheckoutUmlsc(umlsc *Umlsc)
	CommitVertice(vertice *Vertice)
	CheckoutVertice(vertice *Vertice)
	GetLastCommitNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Classdiagrams: make(map[*Classdiagram]struct{}, 0),
	Classshapes: make(map[*Classshape]struct{}, 0),
	Fields: make(map[*Field]struct{}, 0),
	GongdocCommands: make(map[*GongdocCommand]struct{}, 0),
	GongdocStatuss: make(map[*GongdocStatus]struct{}, 0),
	Links: make(map[*Link]struct{}, 0),
	Pkgelts: make(map[*Pkgelt]struct{}, 0),
	Positions: make(map[*Position]struct{}, 0),
	States: make(map[*State]struct{}, 0),
	Umlscs: make(map[*Umlsc]struct{}, 0),
	Vertices: make(map[*Vertice]struct{}, 0),
}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
// Restore shall be performed only on a new database with rowids at 0 (otherwise, it will panic)
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getClassdiagramOrderedStructWithNameField() []*Classdiagram {
	// have alphabetical order generation
	classdiagramOrdered := []*Classdiagram{}
	for classdiagram := range stage.Classdiagrams {
		classdiagramOrdered = append(classdiagramOrdered, classdiagram)
	}
	sort.Slice(classdiagramOrdered[:], func(i, j int) bool {
		return classdiagramOrdered[i].Name < classdiagramOrdered[j].Name
	})
	return classdiagramOrdered
}

// Stage puts classdiagram to the model stage
func (classdiagram *Classdiagram) Stage() *Classdiagram {
	Stage.Classdiagrams[classdiagram] = __member
	return classdiagram
}

// Unstage removes classdiagram off the model stage
func (classdiagram *Classdiagram) Unstage() *Classdiagram {
	delete(Stage.Classdiagrams, classdiagram)
	return classdiagram
}

// commit classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Commit() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

// Checkout classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Checkout() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

func (stage *StageStruct) getClassshapeOrderedStructWithNameField() []*Classshape {
	// have alphabetical order generation
	classshapeOrdered := []*Classshape{}
	for classshape := range stage.Classshapes {
		classshapeOrdered = append(classshapeOrdered, classshape)
	}
	sort.Slice(classshapeOrdered[:], func(i, j int) bool {
		return classshapeOrdered[i].Name < classshapeOrdered[j].Name
	})
	return classshapeOrdered
}

// Stage puts classshape to the model stage
func (classshape *Classshape) Stage() *Classshape {
	Stage.Classshapes[classshape] = __member
	return classshape
}

// Unstage removes classshape off the model stage
func (classshape *Classshape) Unstage() *Classshape {
	delete(Stage.Classshapes, classshape)
	return classshape
}

// commit classshape to the back repo (if it is already staged)
func (classshape *Classshape) Commit() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassshape(classshape)
		}
	}
	return classshape
}

// Checkout classshape to the back repo (if it is already staged)
func (classshape *Classshape) Checkout() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassshape(classshape)
		}
	}
	return classshape
}

func (stage *StageStruct) getFieldOrderedStructWithNameField() []*Field {
	// have alphabetical order generation
	fieldOrdered := []*Field{}
	for field := range stage.Fields {
		fieldOrdered = append(fieldOrdered, field)
	}
	sort.Slice(fieldOrdered[:], func(i, j int) bool {
		return fieldOrdered[i].Name < fieldOrdered[j].Name
	})
	return fieldOrdered
}

// Stage puts field to the model stage
func (field *Field) Stage() *Field {
	Stage.Fields[field] = __member
	return field
}

// Unstage removes field off the model stage
func (field *Field) Unstage() *Field {
	delete(Stage.Fields, field)
	return field
}

// commit field to the back repo (if it is already staged)
func (field *Field) Commit() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitField(field)
		}
	}
	return field
}

// Checkout field to the back repo (if it is already staged)
func (field *Field) Checkout() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutField(field)
		}
	}
	return field
}

func (stage *StageStruct) getGongdocCommandOrderedStructWithNameField() []*GongdocCommand {
	// have alphabetical order generation
	gongdoccommandOrdered := []*GongdocCommand{}
	for gongdoccommand := range stage.GongdocCommands {
		gongdoccommandOrdered = append(gongdoccommandOrdered, gongdoccommand)
	}
	sort.Slice(gongdoccommandOrdered[:], func(i, j int) bool {
		return gongdoccommandOrdered[i].Name < gongdoccommandOrdered[j].Name
	})
	return gongdoccommandOrdered
}

// Stage puts gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) Stage() *GongdocCommand {
	Stage.GongdocCommands[gongdoccommand] = __member
	return gongdoccommand
}

// Unstage removes gongdoccommand off the model stage
func (gongdoccommand *GongdocCommand) Unstage() *GongdocCommand {
	delete(Stage.GongdocCommands, gongdoccommand)
	return gongdoccommand
}

// commit gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Commit() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

// Checkout gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Checkout() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

func (stage *StageStruct) getGongdocStatusOrderedStructWithNameField() []*GongdocStatus {
	// have alphabetical order generation
	gongdocstatusOrdered := []*GongdocStatus{}
	for gongdocstatus := range stage.GongdocStatuss {
		gongdocstatusOrdered = append(gongdocstatusOrdered, gongdocstatus)
	}
	sort.Slice(gongdocstatusOrdered[:], func(i, j int) bool {
		return gongdocstatusOrdered[i].Name < gongdocstatusOrdered[j].Name
	})
	return gongdocstatusOrdered
}

// Stage puts gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) Stage() *GongdocStatus {
	Stage.GongdocStatuss[gongdocstatus] = __member
	return gongdocstatus
}

// Unstage removes gongdocstatus off the model stage
func (gongdocstatus *GongdocStatus) Unstage() *GongdocStatus {
	delete(Stage.GongdocStatuss, gongdocstatus)
	return gongdocstatus
}

// commit gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Commit() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

// Checkout gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Checkout() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

func (stage *StageStruct) getLinkOrderedStructWithNameField() []*Link {
	// have alphabetical order generation
	linkOrdered := []*Link{}
	for link := range stage.Links {
		linkOrdered = append(linkOrdered, link)
	}
	sort.Slice(linkOrdered[:], func(i, j int) bool {
		return linkOrdered[i].Name < linkOrdered[j].Name
	})
	return linkOrdered
}

// Stage puts link to the model stage
func (link *Link) Stage() *Link {
	Stage.Links[link] = __member
	return link
}

// Unstage removes link off the model stage
func (link *Link) Unstage() *Link {
	delete(Stage.Links, link)
	return link
}

// commit link to the back repo (if it is already staged)
func (link *Link) Commit() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLink(link)
		}
	}
	return link
}

// Checkout link to the back repo (if it is already staged)
func (link *Link) Checkout() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLink(link)
		}
	}
	return link
}

func (stage *StageStruct) getPkgeltOrderedStructWithNameField() []*Pkgelt {
	// have alphabetical order generation
	pkgeltOrdered := []*Pkgelt{}
	for pkgelt := range stage.Pkgelts {
		pkgeltOrdered = append(pkgeltOrdered, pkgelt)
	}
	sort.Slice(pkgeltOrdered[:], func(i, j int) bool {
		return pkgeltOrdered[i].Name < pkgeltOrdered[j].Name
	})
	return pkgeltOrdered
}

// Stage puts pkgelt to the model stage
func (pkgelt *Pkgelt) Stage() *Pkgelt {
	Stage.Pkgelts[pkgelt] = __member
	return pkgelt
}

// Unstage removes pkgelt off the model stage
func (pkgelt *Pkgelt) Unstage() *Pkgelt {
	delete(Stage.Pkgelts, pkgelt)
	return pkgelt
}

// commit pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Commit() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPkgelt(pkgelt)
		}
	}
	return pkgelt
}

// Checkout pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Checkout() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPkgelt(pkgelt)
		}
	}
	return pkgelt
}

func (stage *StageStruct) getPositionOrderedStructWithNameField() []*Position {
	// have alphabetical order generation
	positionOrdered := []*Position{}
	for position := range stage.Positions {
		positionOrdered = append(positionOrdered, position)
	}
	sort.Slice(positionOrdered[:], func(i, j int) bool {
		return positionOrdered[i].Name < positionOrdered[j].Name
	})
	return positionOrdered
}

// Stage puts position to the model stage
func (position *Position) Stage() *Position {
	Stage.Positions[position] = __member
	return position
}

// Unstage removes position off the model stage
func (position *Position) Unstage() *Position {
	delete(Stage.Positions, position)
	return position
}

// commit position to the back repo (if it is already staged)
func (position *Position) Commit() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPosition(position)
		}
	}
	return position
}

// Checkout position to the back repo (if it is already staged)
func (position *Position) Checkout() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPosition(position)
		}
	}
	return position
}

func (stage *StageStruct) getStateOrderedStructWithNameField() []*State {
	// have alphabetical order generation
	stateOrdered := []*State{}
	for state := range stage.States {
		stateOrdered = append(stateOrdered, state)
	}
	sort.Slice(stateOrdered[:], func(i, j int) bool {
		return stateOrdered[i].Name < stateOrdered[j].Name
	})
	return stateOrdered
}

// Stage puts state to the model stage
func (state *State) Stage() *State {
	Stage.States[state] = __member
	return state
}

// Unstage removes state off the model stage
func (state *State) Unstage() *State {
	delete(Stage.States, state)
	return state
}

// commit state to the back repo (if it is already staged)
func (state *State) Commit() *State {
	if _, ok := Stage.States[state]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitState(state)
		}
	}
	return state
}

// Checkout state to the back repo (if it is already staged)
func (state *State) Checkout() *State {
	if _, ok := Stage.States[state]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutState(state)
		}
	}
	return state
}

func (stage *StageStruct) getUmlscOrderedStructWithNameField() []*Umlsc {
	// have alphabetical order generation
	umlscOrdered := []*Umlsc{}
	for umlsc := range stage.Umlscs {
		umlscOrdered = append(umlscOrdered, umlsc)
	}
	sort.Slice(umlscOrdered[:], func(i, j int) bool {
		return umlscOrdered[i].Name < umlscOrdered[j].Name
	})
	return umlscOrdered
}

// Stage puts umlsc to the model stage
func (umlsc *Umlsc) Stage() *Umlsc {
	Stage.Umlscs[umlsc] = __member
	return umlsc
}

// Unstage removes umlsc off the model stage
func (umlsc *Umlsc) Unstage() *Umlsc {
	delete(Stage.Umlscs, umlsc)
	return umlsc
}

// commit umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Commit() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlsc(umlsc)
		}
	}
	return umlsc
}

// Checkout umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Checkout() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlsc(umlsc)
		}
	}
	return umlsc
}

func (stage *StageStruct) getVerticeOrderedStructWithNameField() []*Vertice {
	// have alphabetical order generation
	verticeOrdered := []*Vertice{}
	for vertice := range stage.Vertices {
		verticeOrdered = append(verticeOrdered, vertice)
	}
	sort.Slice(verticeOrdered[:], func(i, j int) bool {
		return verticeOrdered[i].Name < verticeOrdered[j].Name
	})
	return verticeOrdered
}

// Stage puts vertice to the model stage
func (vertice *Vertice) Stage() *Vertice {
	Stage.Vertices[vertice] = __member
	return vertice
}

// Unstage removes vertice off the model stage
func (vertice *Vertice) Unstage() *Vertice {
	delete(Stage.Vertices, vertice)
	return vertice
}

// commit vertice to the back repo (if it is already staged)
func (vertice *Vertice) Commit() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVertice(vertice)
		}
	}
	return vertice
}

// Checkout vertice to the back repo (if it is already staged)
func (vertice *Vertice) Checkout() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVertice(vertice)
		}
	}
	return vertice
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMClassdiagram(Classdiagram *Classdiagram)
	CreateORMClassshape(Classshape *Classshape)
	CreateORMField(Field *Field)
	CreateORMGongdocCommand(GongdocCommand *GongdocCommand)
	CreateORMGongdocStatus(GongdocStatus *GongdocStatus)
	CreateORMLink(Link *Link)
	CreateORMPkgelt(Pkgelt *Pkgelt)
	CreateORMPosition(Position *Position)
	CreateORMState(State *State)
	CreateORMUmlsc(Umlsc *Umlsc)
	CreateORMVertice(Vertice *Vertice)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMClassdiagram(Classdiagram *Classdiagram)
	DeleteORMClassshape(Classshape *Classshape)
	DeleteORMField(Field *Field)
	DeleteORMGongdocCommand(GongdocCommand *GongdocCommand)
	DeleteORMGongdocStatus(GongdocStatus *GongdocStatus)
	DeleteORMLink(Link *Link)
	DeleteORMPkgelt(Pkgelt *Pkgelt)
	DeleteORMPosition(Position *Position)
	DeleteORMState(State *State)
	DeleteORMUmlsc(Umlsc *Umlsc)
	DeleteORMVertice(Vertice *Vertice)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Classdiagrams = make(map[*Classdiagram]struct{}, 0)
	stage.Classshapes = make(map[*Classshape]struct{}, 0)
	stage.Fields = make(map[*Field]struct{}, 0)
	stage.GongdocCommands = make(map[*GongdocCommand]struct{}, 0)
	stage.GongdocStatuss = make(map[*GongdocStatus]struct{}, 0)
	stage.Links = make(map[*Link]struct{}, 0)
	stage.Pkgelts = make(map[*Pkgelt]struct{}, 0)
	stage.Positions = make(map[*Position]struct{}, 0)
	stage.States = make(map[*State]struct{}, 0)
	stage.Umlscs = make(map[*Umlsc]struct{}, 0)
	stage.Vertices = make(map[*Vertice]struct{}, 0)
}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Classdiagrams = nil
	stage.Classshapes = nil
	stage.Fields = nil
	stage.GongdocCommands = nil
	stage.GongdocStatuss = nil
	stage.Links = nil
	stage.Pkgelts = nil
	stage.Positions = nil
	stage.States = nil
	stage.Umlscs = nil
	stage.Vertices = nil
}
