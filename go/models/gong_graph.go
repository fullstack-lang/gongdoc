// generated by ModelGongGraphFileTemplate
package models

func IsStaged[Type Gongstruct](stage *StageStruct, instance *Type) (ok bool) {

	switch target := any(instance).(type) {
	// insertion stage
	case *Classdiagram:
		ok = stage.IsStagedClassdiagram(target)

	case *Classshape:
		ok = stage.IsStagedClassshape(target)

	case *DiagramPackage:
		ok = stage.IsStagedDiagramPackage(target)

	case *Field:
		ok = stage.IsStagedField(target)

	case *Link:
		ok = stage.IsStagedLink(target)

	case *Node:
		ok = stage.IsStagedNode(target)

	case *NoteLink:
		ok = stage.IsStagedNoteLink(target)

	case *NoteShape:
		ok = stage.IsStagedNoteShape(target)

	case *Position:
		ok = stage.IsStagedPosition(target)

	case *Tree:
		ok = stage.IsStagedTree(target)

	case *UmlState:
		ok = stage.IsStagedUmlState(target)

	case *Umlsc:
		ok = stage.IsStagedUmlsc(target)

	case *Vertice:
		ok = stage.IsStagedVertice(target)

	}
	return
}

// insertion stage per struct
	func (stage *StageStruct) IsStagedClassdiagram(classdiagram *Classdiagram) (ok bool) {

		_, ok = stage.Classdiagrams[classdiagram]
	
		return
	}

	func (stage *StageStruct) IsStagedClassshape(classshape *Classshape) (ok bool) {

		_, ok = stage.Classshapes[classshape]
	
		return
	}

	func (stage *StageStruct) IsStagedDiagramPackage(diagrampackage *DiagramPackage) (ok bool) {

		_, ok = stage.DiagramPackages[diagrampackage]
	
		return
	}

	func (stage *StageStruct) IsStagedField(field *Field) (ok bool) {

		_, ok = stage.Fields[field]
	
		return
	}

	func (stage *StageStruct) IsStagedLink(link *Link) (ok bool) {

		_, ok = stage.Links[link]
	
		return
	}

	func (stage *StageStruct) IsStagedNode(node *Node) (ok bool) {

		_, ok = stage.Nodes[node]
	
		return
	}

	func (stage *StageStruct) IsStagedNoteLink(notelink *NoteLink) (ok bool) {

		_, ok = stage.NoteLinks[notelink]
	
		return
	}

	func (stage *StageStruct) IsStagedNoteShape(noteshape *NoteShape) (ok bool) {

		_, ok = stage.NoteShapes[noteshape]
	
		return
	}

	func (stage *StageStruct) IsStagedPosition(position *Position) (ok bool) {

		_, ok = stage.Positions[position]
	
		return
	}

	func (stage *StageStruct) IsStagedTree(tree *Tree) (ok bool) {

		_, ok = stage.Trees[tree]
	
		return
	}

	func (stage *StageStruct) IsStagedUmlState(umlstate *UmlState) (ok bool) {

		_, ok = stage.UmlStates[umlstate]
	
		return
	}

	func (stage *StageStruct) IsStagedUmlsc(umlsc *Umlsc) (ok bool) {

		_, ok = stage.Umlscs[umlsc]
	
		return
	}

	func (stage *StageStruct) IsStagedVertice(vertice *Vertice) (ok bool) {

		_, ok = stage.Vertices[vertice]
	
		return
	}


// StageBranch stages instance and apply StageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func StageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion stage branch
	case *Classdiagram:
		stage.StageBranchClassdiagram(target)

	case *Classshape:
		stage.StageBranchClassshape(target)

	case *DiagramPackage:
		stage.StageBranchDiagramPackage(target)

	case *Field:
		stage.StageBranchField(target)

	case *Link:
		stage.StageBranchLink(target)

	case *Node:
		stage.StageBranchNode(target)

	case *NoteLink:
		stage.StageBranchNoteLink(target)

	case *NoteShape:
		stage.StageBranchNoteShape(target)

	case *Position:
		stage.StageBranchPosition(target)

	case *Tree:
		stage.StageBranchTree(target)

	case *UmlState:
		stage.StageBranchUmlState(target)

	case *Umlsc:
		stage.StageBranchUmlsc(target)

	case *Vertice:
		stage.StageBranchVertice(target)

	}
}

// insertion stage branchper struct
func (stage *StageStruct) StageBranchClassdiagram(classdiagram *Classdiagram) {

	// check if instance is already staged
	if IsStaged(stage, classdiagram) {
		return
	}

	classdiagram.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _classshape := range classdiagram.Classshapes {
		StageBranch(stage, _classshape)
	}
	for _, _noteshape := range classdiagram.NoteShapes {
		StageBranch(stage, _noteshape)
	}

}

func (stage *StageStruct) StageBranchClassshape(classshape *Classshape) {

	// check if instance is already staged
	if IsStaged(stage, classshape) {
		return
	}

	classshape.Stage()

	//insertion point for the staging of instances referenced by pointers
	if classshape.Position != nil {
		StageBranch(stage, classshape.Position)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _field := range classshape.Fields {
		StageBranch(stage, _field)
	}
	for _, _link := range classshape.Links {
		StageBranch(stage, _link)
	}

}

func (stage *StageStruct) StageBranchDiagramPackage(diagrampackage *DiagramPackage) {

	// check if instance is already staged
	if IsStaged(stage, diagrampackage) {
		return
	}

	diagrampackage.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _classdiagram := range diagrampackage.Classdiagrams {
		StageBranch(stage, _classdiagram)
	}
	for _, _umlsc := range diagrampackage.Umlscs {
		StageBranch(stage, _umlsc)
	}

}

func (stage *StageStruct) StageBranchField(field *Field) {

	// check if instance is already staged
	if IsStaged(stage, field) {
		return
	}

	field.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchLink(link *Link) {

	// check if instance is already staged
	if IsStaged(stage, link) {
		return
	}

	link.Stage()

	//insertion point for the staging of instances referenced by pointers
	if link.Middlevertice != nil {
		StageBranch(stage, link.Middlevertice)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchNode(node *Node) {

	// check if instance is already staged
	if IsStaged(stage, node) {
		return
	}

	node.Stage()

	//insertion point for the staging of instances referenced by pointers
	if node.Classdiagram != nil {
		StageBranch(stage, node.Classdiagram)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range node.Children {
		StageBranch(stage, _node)
	}

}

func (stage *StageStruct) StageBranchNoteLink(notelink *NoteLink) {

	// check if instance is already staged
	if IsStaged(stage, notelink) {
		return
	}

	notelink.Stage()

	//insertion point for the staging of instances referenced by pointers
	if notelink.Classshape != nil {
		StageBranch(stage, notelink.Classshape)
	}
	if notelink.Link != nil {
		StageBranch(stage, notelink.Link)
	}
	if notelink.Middlevertice != nil {
		StageBranch(stage, notelink.Middlevertice)
	}

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchNoteShape(noteshape *NoteShape) {

	// check if instance is already staged
	if IsStaged(stage, noteshape) {
		return
	}

	noteshape.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _notelink := range noteshape.NoteLinks {
		StageBranch(stage, _notelink)
	}

}

func (stage *StageStruct) StageBranchPosition(position *Position) {

	// check if instance is already staged
	if IsStaged(stage, position) {
		return
	}

	position.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchTree(tree *Tree) {

	// check if instance is already staged
	if IsStaged(stage, tree) {
		return
	}

	tree.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _node := range tree.RootNodes {
		StageBranch(stage, _node)
	}

}

func (stage *StageStruct) StageBranchUmlState(umlstate *UmlState) {

	// check if instance is already staged
	if IsStaged(stage, umlstate) {
		return
	}

	umlstate.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchUmlsc(umlsc *Umlsc) {

	// check if instance is already staged
	if IsStaged(stage, umlsc) {
		return
	}

	umlsc.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _umlstate := range umlsc.States {
		StageBranch(stage, _umlstate)
	}

}

func (stage *StageStruct) StageBranchVertice(vertice *Vertice) {

	// check if instance is already staged
	if IsStaged(stage, vertice) {
		return
	}

	vertice.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

